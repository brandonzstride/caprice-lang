(* TEST
  include finite-well-typed;
*)

(* simple id fun *)

let id : int -> int = fun x -> x

(* higher order function applications *)

let f (g : int -> int) (x : (int -> int) -> bool) : bool = 
  x g


(* simple dependent functions *)

let test (type a b) (f : a -> b) (type c) : list c =
  []

let test (type a) : a = assume false

let _ = (type a) -> list a

let B x = 
  if x > 0 then int else bool

let f (dependent a : int) (b : B a) : int =
  if a > 0 then b else 
    if b then 3 else 2

(* This is a dependent function type with a refined parameter *)
let _ = (x : int | x > 0) -> if x > 10 then int else bool

(* This is just a function type with a refined parameter *)
let _ = { x : int | x > 0 } -> int


(* generated functions *)

(* Generated function should pass *)
let f (type a b) (g : a -> list b) : a -> list b =
  g

(* Generated dependent function is a regular function *)
let f (dep k : int) (g : (i : int | i > k) -> if i > 10 then list int else bool) 
  : { i : int | i > 10 && i > k } -> list int =
  g

(* Generated function can check as a dependent function *)
let f (g : { i : int | i > 0 } -> { j : int | j < 0 })
  : (i : int | i > 0) -> if i < 10 then int else { j : int | j < 0 } =
  g

(* Generated dependent function subtyping *)
let f (g : (x : { a : int }) -> if x.a > 0 then { b : bool | b == (x.a == 10)} else { i : int | i == x.a })
  : (y : { a : int ; b : bool }) -> if y.a > 0 then bool else int =
  g
