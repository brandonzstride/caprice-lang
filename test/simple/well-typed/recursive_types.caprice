(* TEST
  include splayable;
*)

(* mu is not used *)

let t = mu t. { i : int | i >= 0 } -> int

let f (g : int -> { j : int | j < 0 }) : { i : int | i > 0 } -> { j : int | j <= 0 } =
  let h : t = g in
  h (* h is a wrapped value *)

let f (g : t) : { i : int | i >= 0 } -> int =
  g


(* self-returning type *)

let t = mu t. { f : int -> t }

let g (x : t) : unit =
  let y : t = x in
  ()

let rec f (i : int) : t = (* does not terminate without splaying *)
  if i <= 0 then
    { f = f }
  else
    { f = fun j -> f (i - j) }


(* negative mu *)

let t = mu t.
  | `A of t -> int
  | `B of unit

let _ : t =
  `A (fun t ->
    match t with
    | `A f -> f (`B ())
    | `B () -> 0
    end
  )

let _ : t = `B ()

let rec f (_ : unit) : t =
  `A (fun t ->
    match t with
    | `A g -> g (f ()) + 1
    | `B () -> 0
    end
  )

(* member of recursive type is a type *)

let t : type = mu t. singletype { a : type ; b : t }

let f (x : t) : type = x

let g (dep x : t) (dep r : x) (y : r.a) : `T of r.a =
  `T y
