(* TEST
  include splayable;
*)

let ls = [ 1 ; 2 ; 3 ]

let _ =
  match ls with
  | (a :: b :: c :: [] | b :: a :: []) ->
    assert (a == 1 && b == 2)
  end

let f (x : `A of unit | `B of unit | `C of unit | `D of unit | `E of unit) : int =
  match x with
  | `A _
  | `B _
  | `C _ -> 0
  | (`A _ | `B _ | `C _ | `D _ | `E _ as v) ->
    match v with
    (* This is the same as the pattern above *)
    | (`A _ | `B _ | `C _ | `D _ | `E _) as u ->
      match u with
      | `D _ | `E _ -> 1
      end
    end
  end

let f (x : `A of unit | `B of unit | `C of unit | `D of unit | `E of unit) : int =
  match x with
  | `A _
  | `B _ -> 0
  | (`A _ | `B _ | `C _ | `D _ | `E _ as v) ->
    match v with
    (* This is the same as the pattern above *)
    | (`A _ | `B _ | `C _ | `D _ | `E _) as u ->
      match u with
      | `C _ | `D _ | `E _ -> 1
      end
    end
  end

let g (ls : list int) : int =
  match ls with
  | (_ :: (_ :: [] as tl) | _ :: ([] as tl)) ->
    match tl with
    | a :: [] -> a
    | [] -> 0
    end
  | [] -> 1
  | a :: b :: c :: _ -> a + b + c
  end

let h (x : `A of unit | `B of (`A of unit | `B of `A of unit)) : bool =
  match x with
  | `A _ | `B `A _ -> true
  | `B `B `A _ -> false
  end

let k (x : list int) : int =
  match x with
  | _ :: _ ->
    match x with
    | _ :: _ as y ->
      (* y is bound to the entire x, not the tail *)
      match y with
      | hd :: _ -> hd
      end
    end
  | [] -> 0
  end
