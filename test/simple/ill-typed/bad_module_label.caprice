(* TEST
  include refutable;
*)

let v = struct
  let a = fun x -> x
  let b = fun x -> x
  let c = 0
end

(* Even if we don't wrap when evaluating the module initially, we wrap when evaluating
  it when we wrap finally, so when we wrap `v` with type `t`, we catch the error, but not
  when checking if `v` has type `t`. *)
let t = sig
  val a : int -> int
  val b : int -> int
  val c : 
    if a true then (* ERROR: misuses a *)
      int
    else
      bool
end

let w : t = v
