(* TEST
  include splayable;
*)

let t a =
  { run : (type r) -> (a -> r) -> r }

let bind (type a b) (x : t a) (f : a -> t b) : t b =
  { run = fun r k ->
    x.run r (fun a ->
      (f a).run r k
    )
  }

let return (type a) (a : a) : t a =
  { run = fun r k -> k a }

let run (type a r) (x : t a) (k : a -> r) : r =
  x.run r k

(* We don't want the user to write this (it explodes) but they _can_ write it. *)
(* let rec summate (dep n : int) : { m : t int | 
  run int int m (fun i -> i) == n * (n + 1) / 2
  } =
  if n <= 0 then return int 0 else
  bind int int (summate (n - 1)) (fun sum ->
    return int (sum + n)
  ) *)

let closed_sum n = n * (n + 1) / 2

let closed_sum_t n = { i : int | i == closed_sum n }

(*
  This doesn't explode, but it requires a lot of hand-holding for typing.
  See `cps_monad_ho_sub.caprice` test for why it needs so much explicit typing.
*)
let rec summate (dep n : int | n >= 0) : t (closed_sum_t n) =
  if n <= 0 then return (closed_sum_t 0) 0 else
  bind (closed_sum_t (n - 1)) (closed_sum_t n) (summate (n - 1)) (fun sum ->
    return (closed_sum_t n) (sum + n)
  )
