(* TEST
  typing = ill-typed;
  flags = " -s -w"; # the goal is to test that splaying finds errors
  speed = fast;
*)

let t a = mu t.
  | `Leaf of unit
  | `Branch of
    { item : a
    ; left : t
    ; right : t }

let rec size (type a) (tree : t a) : int =
  match tree with
  | `Leaf () -> 0
  | `Branch b -> size a b.left + size a b.right + 1
  end

let rec height (type a) (tree : t a) : int =
  match tree with
  | `Leaf () -> 0
  | `Branch b ->
    let l = height a b.left in
    let r = height a b.right in
    1 + if l > r then l else r
  end

let abs x = 
  if x < 0
  then -1 * x
  else x

let rec is_balanced (type a) (tree : t a) : bool =
  match tree with
  | `Leaf () -> true
  | `Branch b -> 
    abs (height a b.left - height a b.right) <= 1
    && is_balanced a b.left
    && is_balanced a b.right
  end

let rec map (type a b) (f : a -> b) (tree : t a) : t b =
  match tree with
  | `Leaf () -> `Leaf ()
  | `Branch r -> 
    `Branch { item = f r.item ; left = map a b f r.left ; right = map a b f r.right }
  end

let rec fold_left (type a acc) (f : acc -> a -> acc) (init : acc) (tree : t a) : acc =
  match tree with
  | `Leaf () -> init
  | `Branch b ->
    fold_left a acc f (f (fold_left a acc f init b.left) b.item) b.right 
  end

(* Slow usage of fold_left. *)
let is_ordered (type a) (tree : t a) (compare : a -> a -> int) : bool =
  let res =
    fold_left a (
      | `Empty of unit
      | `Not_ordered of unit
      | `Ordered_with_min of a
    ) (fun acc a -> 
      match acc with
      | `Not_ordered () -> `Not_ordered ()
      | `Empty () -> `Ordered_with_min a
      | `Ordered_with_min m ->
          if compare a m > 0
          then `Ordered_with_min a
          else `Not_ordered ()
      end
    ) (`Empty ()) tree
  in
  match res with
  | `Empty () | `Ordered_with_min () -> true (* ERROR: `Ordered_with_min does not have unit payload *)
  | `Not_ordered _ -> false
  end