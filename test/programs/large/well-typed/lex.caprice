(* TEST
  include splayable;
*)

let string = list int
let eof = -1

let Token =
  | `TokMult of unit
  | `TokPlus of unit
  | `TokInt of string
  | `TokVar of string
  | `TokMinus of unit
  | `TokOpenParen of unit
  | `TokCloseParen of unit
  | `TokLet of unit
  | `TokIn of unit
  | `TokEqual of unit
  | `TokAfter of unit
  | `TokBefore of unit
  | `Invalid of int

let Tree = mu Tree.
  | `EInt of int
  | `EVar of string
  | `EOpPlus of Tree * Tree
  | `EOpMinus of Tree * Tree
  | `OpTimes of Tree * Tree
  | `EAfter of Tree
  | `EBefore of Tree
  | `ELet of {var: string; e1:Tree; e2:Tree}
  | `Invalid of int

let Result = fun t -> `Success of t | `Failure of int
let TokResult = Result {s:string; tok:Token}
(* let StringResult = Result {result:string; file:string} *)

(* let pure x = `Success x

let bind x f = 
  match x with 
  | `Failure _ -> x
  | `Success y -> f y
  end  *)

let compose f g chars = 
  match f chars with 
  | `Success x -> `Success x
  | `Failure _ -> g chars
  end

(* let take_char (x:string): int =
  match x with
  | [] -> -1
  | a :: _ -> a
  end *)

(*
  I'm not exactly sure what this is doing, but I have replicated the effective
  behavior of the commented code below.

  The ideal types would be that long has greater length than short, but our type
  system cannot prove such a thing, so I just write an `assume false` to
  cover that case.

  Also, this function is not used anymore.
*)
(* let rec str_compare (short : string) (long : string) : { eq : bool ; s : string } =
  match short, long with
  | [], [] -> { eq = true ; s = [] }
  | [], _ :: tl -> { eq = true ; s = tl }
  | a :: tl1, b :: tl2 ->
    if a == b then
      str_compare tl1 tl2
    else
      { eq = false ; s = [] }
  | _, [] -> assume false
  end *)

    (* let hd = take_char short in
    let a = take_char long in
    if hd==-1 then if a==[] then {eq=true; s=[]} else {eq=true; s=(drop_char long)}
    else if hd==a then str_compare (drop_char short) (drop_char long) else {eq=false; s=[]} *)

let rec make_tokenize (codes : list int | match codes with [] -> false | _ -> true end) 
  (tok : Token) (s : string) : TokResult =
  match s, codes with
  | [], _ -> `Failure 1
  | hd :: tl, code :: [] ->
    if hd == code then
      `Success { s = tl ; tok = tok }
    else
      `Failure 0
  | hd :: tl, code :: xs ->
    if hd == code then
      make_tokenize xs tok tl
    else
      `Failure 0
  end

let tokenize_mult = make_tokenize [ 42 ] (`TokMult ())
let tokenize_plus = make_tokenize [ 43 ] (`TokPlus ())
let tokenize_minus = make_tokenize [ 45 ] (`TokMinus ())
let tokenize_openparen = make_tokenize [ 40 ] (`TokOpenParen ())
let tokenize_closeparen = make_tokenize [ 41 ] (`TokCloseParen ())
let tokenize_equal = make_tokenize [ 61 ] (`TokEqual ())
let tokenize_in = make_tokenize [ 105 ; 110 ] (`TokIn ())
let tokenize_let = make_tokenize [ 108 ; 101 ; 116 ] (`TokLet ())
let tokenize_after = make_tokenize [ 97 ; 102 ; 116 ; 101 ; 114 ] (`TokAfter ())
let tokenize_before = make_tokenize [ 98 ; 101 ; 102 ; 111 ; 114 ; 101 ] (`TokBefore ())

let rev (type a) (l : list a) : list a =
  let rec aux (acc : list a) (ls : list a) : list a =
    match ls with
    | [] -> acc
    | hd :: tl -> aux (hd :: acc) tl
    end
  in
  aux [] l

let match_sequence (file : string) (cond : int -> bool) (ret : string -> Token) : TokResult =
  let rec match_seq (acc : string) (file : string) : TokResult =
    match file with
    | [] -> `Failure 1 (* unexpected eof *)
    | hd :: tl -> 
      if hd == 32 then (* found space, ending sequence *)
        `Success { s = tl ; tok = ret (rev int acc) }
      else
        if cond hd then (* character satisfies condition *)
          match_seq (hd :: acc) tl
        else
          `Failure 0
    end
  in
  match_seq [] file

let tokenize_int s = match_sequence s (fun c -> 48 <= c && c <= 57) (fun i -> `TokInt i)
let tokenize_var s = match_sequence s (fun c -> 65 <= c && c <= 90 || 97 <= c && c <= 122) (fun i -> `TokVar i)

let rec lex_token (file: string) : list Token =
  let token =
    compose tokenize_mult
    (compose tokenize_plus
    (compose tokenize_minus
    (compose tokenize_openparen
    (compose tokenize_closeparen
    (compose tokenize_equal
    (compose tokenize_in
    (compose tokenize_let
    (compose tokenize_after
    (compose tokenize_before
    (compose tokenize_int
    (compose tokenize_var
    (fun x -> `Failure 1)))))))))))) file
  in
  match token with 
  | `Success x -> x.tok :: lex_token x.s
  | `Failure y -> [`Invalid y]
  end

(* Parse the integer four. Because of splaying, we cannot verify this actually evaluates to [ `TokInt [ 52 ] ; `Invalid  ]. *)
let four = lex_token [52;32;-1]

(* This only works when not type splaying. So turn off splaying, and see no error here! *)
(* let _ =
  match four with
  | `TokInt (a :: []) :: `Invalid _ :: [] -> assert (a == 52)
  end *)

(* Run this without splaying to see that this errors quickly. We really find the error fast! *)
(* let _ =
  match four with
  | `TokInt (a :: []) :: `Invalid _ :: [] -> assert (a == 51) (* WRONG! *)
  end *)
