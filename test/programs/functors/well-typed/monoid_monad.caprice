(* TEST
  include finite-well-typed;
*)

let MONOID = sig
  val t : type
  val neutral : t 
  val combine : t -> t -> t
end

let MONAD = sig
  val m : type --> type
  val return : (type a) -> a -> m a
  val bind : (type a b) -> m a -> (a -> m b) -> m b
end

let F : (X : MONOID) -> (M : MONAD) -> sig
  val t = M.m X.t (* good use of singletype sugar here *)
  val neutral : t
  val combine : t -> t -> t
end = fun X M -> struct
  let t = M.m X.t
  let neutral = M.return X.t X.neutral
  let combine a_m b_m =
    let bind = M.bind X.t X.t in
    bind a_m (fun a ->
      bind b_m (fun b ->
        M.return X.t (X.combine a b)
      )
    )
end