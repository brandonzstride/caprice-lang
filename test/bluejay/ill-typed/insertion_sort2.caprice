(* TEST
  include refutable;
*)

(* Insert into empty list fails *)

let is_nonempty lst =
  match lst with
  | [] -> false
  | _ -> true
  end

let rec ne_sorted lst =
  match lst with
  | [] | _ :: [] -> true
  | a :: (b :: _ as tl) ->
    a <= b && ne_sorted tl
  end

let rec foldl f b l =
  match l with
  | [] -> b
  | x :: xs -> foldl f (f x b) xs
  end

let rec insert x l =
  match l with
  | [] -> [] (* ERROR: should be [ x ] *)
  | h :: t ->
    if x <= h
    then x :: l
    else h :: (insert x t)
  end

let ret_type xs =
  { l : list int |
    ne_sorted l
    &&
      if is_nonempty xs
      then is_nonempty l
      else not (is_nonempty l)
  }

let sort (dependent xs : list int) : ret_type xs =
  foldl insert [] xs