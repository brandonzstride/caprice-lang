{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Caprice",
  "scopeName": "source.caprice",
  "patterns": [
    {"include": "#comments"},
    {"include": "#numbers"},
    {"include": "#keywords"},
    {"include": "#operators"},
    {"include": "#identifiers"},
    {"include": "#brackets"}
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.block.caprice",
          "begin": "\\(\\*",
          "end": "\\*\\)",
          "patterns": [
            {"include": "#comments"}
          ]
        }
      ]
    },
    
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.integer.caprice",
          "match": "\\b[0-9]+\\b"
        }
      ]
    },
    
    "keywords": {
      "patterns": [
        {
          "name": "keyword.other.caprice",
          "match": "\\b(if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and|mu|defer|abstract)\\b"
        },
        {
          "name": "constant.language.boolean.caprice",
          "match": "\\b(true|false)\\b"
        },
        {
          "name": "support.type.builtin.caprice",
          "match": "\\b(int|bool|unit|top|bottom|list|singletype|type)\\b"
        },
        {
          "name": "support.function.builtin.caprice",
          "match": "\\b(input|assert|assume|not)\\b"
        }
      ]
    },

    "operators": {
      "patterns": [
        {
          "comment": "infix operators - arithmetic",
          "name": "entity.name.function.caprice",
          "match": "[+\\-*/%]"
        },
        {
          "comment": "infix operators - comparison", 
          "name": "entity.name.function.caprice",
          "match": "(<>|<=?|>=?)"
        },
        {
          "comment": "infix operators - logical and pipe",
          "name": "entity.name.function.caprice",
          "match": "(\\|\\||&&|\\|>)"
        },
        {
          "comment": "assignment operator",
          "name": "entity.name.function.caprice",
          "match": "="
        },
        {
          "comment": "type operators",
          "name": "entity.name.function.caprice",
          "match": "(->|-->)"
        },
        {
          "comment": "vertical bar for types/patterns",
          "name": "keyword.other.caprice",
          "match": "(?<!:)(\\|)(?!\\||>)"
        },
        {
          "comment": "ampersand operator",
          "name": "keyword.other.caprice",
          "match": "&"
        },
        {
          "comment": "list cons operator",
          "name": "keyword.other.caprice",
          "match": "::"
        },
        {
          "comment": "type annotation",
          "name": "keyword.other.caprice punctuation.other.colon punctuation.colon",
          "match": ":"
        },
        {
          "comment": "field accessor",
          "name": "keyword.other.caprice punctuation.other.period punctuation.separator.period",
          "match": "\\."
        },
        {
          "comment": "semicolon separator",
          "name": "keyword.other.caprice punctuation.separator.terminator punctuation.separator.semicolon",
          "match": ";"
        }
      ]
    },

    "identifiers": {
      "patterns": [
        {
          "comment": "wildcard underscore",
          "name": "constant.language.caprice",
          "match": "\\b_\\b"
        },
        {
          "comment": "function name after val declaration",
          "name": "entity.name.function.caprice",
          "match": "(?<=\\bval\\s+)([a-z_][[:word:]']*)",
          "captures": {
            "1": {"name": "entity.name.function.caprice"}
          }
        },
        {
          "comment": "function name in let bindings (followed by parameters)",
          "name": "entity.name.function.caprice", 
          "match": "(?<=\\blet\\s+(?:rec\\s+)?)([a-z_][[:word:]']*)(?=\\s+(?:\\(type\\s+[^)]+\\)|[a-z_A-Z(]|\\([^)]*:[^)]*\\)))",
          "captures": {
            "1": {"name": "entity.name.function.caprice"}
          }
        },
        {
          "comment": "type parameters in parentheses",
          "name": "meta.type-parameters.caprice",
          "match": "\\((type)\\s+([a-z_][[:word:]']*(?:\\s+[a-z_][[:word:]']*)*)\\)",
          "captures": {
            "1": {"name": "keyword.other.caprice"},
            "2": {"name": "variable.parameter.caprice"}
          }
        },
        {
          "comment": "function after dot (record/module projection used as function)",
          "name": "entity.name.function.caprice",
          "match": "(?<=\\.)([a-z_][[:word:]']*)(?=\\s+(?!\\b(?:if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and)\\b)(?:[a-z_A-Z][[:word:]']*|\\([^)]*\\)|[0-9]+|\\b(?:int|bool|unit|top|bottom|singletype|list|type)\\b))",
          "captures": {
            "1": {"name": "entity.name.function.caprice"}
          }
        },
        {
          "comment": "fun parameters - all identifiers after fun until ->",
          "name": "variable.parameter.caprice", 
          "match": "(?<=\\bfun\\s+)([a-z_][[:word:]']*(?:\\s+[a-z_][[:word:]']*)*)(?=\\s*->)",
          "captures": {
            "1": {"name": "variable.parameter.caprice"}
          }
        },
        {
          "comment": "function call immediately after keywords (only when followed by arguments, not other keywords)",
          "name": "entity.name.function.caprice",
          "match": "(?<=\\b(?:if|then|else|in|end|of|and)\\s+)([a-z_][[:word:]']*)(?=\\s+(?!\\b(?:if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and|->)\\b)(?:[a-z_A-Z][[:word:]']*|\\([^)]*\\)|[0-9]+|\\b(?:int|bool|unit|top|bottom|singletype|list|type)\\b))",
          "captures": {
            "1": {"name": "entity.name.function.caprice"}
          }
        },
        {
          "comment": "function call - identifier NOT preceded by another identifier (to avoid matching arguments as functions)",
          "name": "entity.name.function.caprice",
          "match": "(?<!\\b[a-z_A-Z][[:word:]']*\\s)(?<!\\)\\s*)(?<!\\b[a-z_A-Z][[:word:]']*\\.)(?<!\\blet\\s+(?:rec\\s+)?)(?<!\\bval\\s+)\\b([a-z_][[:word:]']*)(?=\\s+(?!\\b(?:if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and|->)\\b)(?:[a-z_A-Z][[:word:]']*|\\([^)]*\\)|[0-9]+|\\b(?:int|bool|unit|top|bottom|singletype|list|type)\\b))",
          "captures": {
            "1": {"name": "entity.name.function.caprice"}
          }
        },
        {
          "comment": "capital identifier for constructor, exception, or module",
          "name": "entity.name.type.module.caprice",
          "match": "\\b[[:upper:]][[:word:]']*('|\\b)"
        },
        {
          "comment": "builtin types used as values (including in function arguments)",
          "name": "support.type.builtin.caprice",
          "match": "\\b(int|bool|unit|top|bottom|singletype|list|type)\\b"
        },
        {
          "comment": "lowercase identifier (default case)",
          "name": "variable.other.caprice",
          "match": "\\b[[:lower:]_][[:word:]']*('|\\b)"
        },
        {
          "comment": "polymorphic variant tag",
          "name": "constant.language.polymorphic-variant.caprice",
          "match": "\\`[[:alpha:]][[:word:]']*\\b"
        },
        {
          "comment": "empty list (can be used as a constructor)",
          "name": "constant.language.list.caprice",
          "match": "\\[\\]"
        }
      ]
    },

    "brackets": {
      "patterns": [
        {
          "name": "punctuation.section.braces.begin.caprice",
          "match": "\\{"
        },
        {
          "name": "punctuation.section.braces.end.caprice",
          "match": "\\}"
        },
        {
          "name": "punctuation.section.brackets.begin.caprice",
          "match": "\\["
        },
        {
          "name": "punctuation.section.brackets.end.caprice",
          "match": "\\]"
        },
        {
          "name": "punctuation.section.parens.begin.caprice",
          "match": "\\("
        },
        {
          "name": "punctuation.section.parens.end.caprice",
          "match": "\\)"
        },
        {
          "name": "punctuation.section.record.begin.caprice",
          "match": "\\{:"
        },
        {
          "name": "punctuation.section.record.end.caprice",
          "match": ":\\}"
        }
      ]
    }
  }
}