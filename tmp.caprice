
(*
  Any deterministic function can act nondeterministic
*)
let _ : (int --> int) -> int -> int =
  fun f -> f

(*
  This is deterministically returns the same function and is fine
*)
let _ : (int -> int) --> int -> int =
  fun f -> f

let _ : (int --> int -> int) --> int =
  fun f -> 
    let _ = f 0 in (* no problems here *)
    0 (* but then there's nothing we can do to get a deterministic output *)

let _ : (int --> int --> int) --> int =
  fun f ->
    f 0 0 (* safe to apply *)

let _ : (int --> int) -> int --> int =
  fun f -> f

let _ : ((int -> int) --> int) -> (int -> int) -> int =
  fun f g ->
    let _ = assert (f g == f g) in
    f g

(*
  Here is how we assert that X.t is the returned t
*)
(* let F : (X : sig val t : type --> type end) -> sig
  val t : (a : type) -> singletype (X.t a) (* like an eta equivalence, right? *)
end = fun X -> struct
  let t = X.t
end *)

(* type checker says this is well typed *)
let f (dep tf : type --> type) (type a) : singletype (tf a) =
  tf a

(* and this is ill-typed (wrongly, because we actually need to apply to deterministic functions to check them) *)
let f (dep tf : type --> type) : (type a) -> singletype (tf a) =
  tf

let f (dep tf : type --> type) (type a) (x : tf a) (y : tf a) (b : bool) : tf a =
  if b then x else y

(*
  Even though singletype checks for equality, let's check one more time
*)
(* let _ =
  let X = struct let t a = { a : a } end in
  let M = F X in
  let f (type a) (x : X.t a) : M.t a =
    x
  in
  f *)

(*
  This is saying that Y.t = X.t, and we check that it is still type --> type.
*)
let F : (X : sig val t : type --> type end) -> (Y : sig val t : (a : type) -> singletype (X.t a) end) -> sig
  val t : type --> type
end = fun X Y -> struct
  let t = Y.t
end

(*
  ..
*)
let _ =
  let X = struct let t a = `A of a end in
  let Y = X in
  let M = F X Y in
  let f (type a) (x : X.t a) (y : Y.t a) : { x : M.t a ; y : M.t a } =
    { x = x ; y = y }
  in
  f

let _ : (bool --> int) -> bool -> unit =
  fun f b ->
    let ft = f true in
    if b then
      assert (f true == f b)
    else
      ()

(* let _ : (singletype type --> int) -> singletype type -> singletype type -> int =
  fun f a b ->
    if f a == f b
    then 0
    else false *)
